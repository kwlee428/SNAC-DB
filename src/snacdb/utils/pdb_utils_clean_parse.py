import argparse
import Bio
from Bio.PDB.MMCIF2Dict import MMCIF2Dict
from Bio.PDB.MMCIFParser import MMCIFParser
from Bio.PDB.PDBParser import PDBParser
from Bio.PDB.Polypeptide import protein_letters_3to1
from Bio.SeqIO import PdbIO
from Bio import pairwise2
import numpy as np
import os
from Bio import PDB
import re

from Bio.PDB import Structure, Model, Chain, Residue, Atom

import sys
sys.path.append(os.path.abspath(os.path.dirname(__file__)))

from residue_constants import atom_types 

protein_letters_1to3 = {val: key for key, val in protein_letters_3to1.items()}


def assign_bfactor_from_array(structure: Structure, bfactor_dict: dict):
    """
    Assigns B-factor values from a provided dictionary to the corresponding residues in a Biopython structure.
    For chains not included in the dictionary, assigns a default B-factor of 0.

    Parameters:
    - structure (Structure): Biopython Structure object.
    - bfactor_dict (dict): Dictionary mapping chain IDs to 1D NumPy arrays of B-factor values.
                           The length of each array must match the number of residues in the respective chain.

    Returns:
    - Structure: The modified Biopython Structure object with updated B-factor values.
    """
    for model in structure:
        for chain in model:
            chain_id = chain.id
            residues = [res for res in chain if res.id[0] == " "]

            if chain_id in bfactor_dict:
                bfactor_array = bfactor_dict[chain_id]
                if len(residues) != len(bfactor_array):
                    raise ValueError(f"Chain {chain_id}: Mismatch between number of residues ({len(residues)}) and B-factor array length ({len(bfactor_array)})")

                # Assign provided B-factor values
                for residue, bfactor in zip(residues, bfactor_array):
                    for atom in residue:
                        atom.set_bfactor(float(bfactor))
            else:
                # Assign B-factor of 0 for all residues in chains not specified in the dictionary
                for residue in residues:
                    for atom in residue:
                        atom.set_bfactor(0.0)

    return structure  # Return the modified structure with updated B-factors

def merge_chains(model, chains_to_merge, merged_chain_id=None, default_model_id=0):
    """
    Merges multiple chains in a Biopython model into a single chain, ensuring unique residue IDs.

    Parameters:
    - model (Model): Biopython Model object containing the chains.
    - chains_to_merge (list): List of chain IDs to merge. The first chain in the list 
                              will be the primary chain to which the residues of other 
                              chains are added.
    - merged_chain_id (str, optional): Custom ID for the merged chain. If not provided,
                                       the ID will be a concatenation of the input chain IDs.

    Returns:
    - Model: The updated model with the specified chains merged into a single chain.
    """
    primary_chain = model[default_model_id][chains_to_merge[0]]
    current_residue_number = max(res.id[1] for res in primary_chain.get_residues()) + 1

    # Collect residues to add, making deep copies to avoid modifying originals
    residues_to_add = []
    for chain_id in chains_to_merge[1:]:
        chain = model[default_model_id][chain_id]
        
        # Collect deep copies of residues from the secondary chain
        for res in list(chain.get_residues()):  # Use list to stabilize iteration
            res.id = (" ", current_residue_number, " ")  # Assign a unique ID
            current_residue_number += 1
            residues_to_add.append(res)

        # Detach the chain after collecting residues
        model[default_model_id].detach_child(chain_id)

    # Add all collected residues to the primary chain
    for res in residues_to_add:
        primary_chain.add(res)

    # Update the ID of the primary chain
    primary_chain.id = merged_chain_id if merged_chain_id else "".join(chains_to_merge)

    # Return the updated model
    return model


def write_dict_to_cif(structure_dict, output_file, remark="Generated by Abhinav Gupta, Sanofi"):
    """
    Writes a CIF file from a structure dictionary.

    The dictionary should contain chain-level information with:
    - 'seq': Full sequence (including missing residues) as a string.
    - 'atom37': Coordinates as a NumPy array of shape (seq_length, 37, 3).
    - 'b_factor': Optional NumPy array of shape (seq_length, 37).

    :param structure_dict: Dictionary containing structure data.
    :param output_file: Path to save the CIF file.
    :param remark: Custom remark to include in the CIF header.
    """
    with open(output_file, 'w') as cif_file:
        # Write header
        cif_file.write(f"# {remark}\n")
        cif_file.write("data_protein_structure\n\n")
        
        # Entity and sequence information
        cif_file.write("loop_\n")
        cif_file.write("_entity_poly.entity_id\n")
        cif_file.write("_entity_poly.type\n")
        cif_file.write("_entity_poly.pdbx_seq_one_letter_code\n")
        cif_file.write("_entity_poly.pdbx_strand_id\n")
        
        entity_id = 1
        for chain_id, chain_data in structure_dict.items():
            seq = chain_data["seq"]
            cif_file.write(f"{entity_id} polypeptide(L) '{seq}' {chain_id}\n")
            entity_id += 1
        
        cif_file.write("\n")
        
        # Atom information
        cif_file.write("loop_\n")
        cif_file.write("_atom_site.group_PDB\n")
        cif_file.write("_atom_site.id\n")
        cif_file.write("_atom_site.type_symbol\n")
        cif_file.write("_atom_site.label_atom_id\n")
        cif_file.write("_atom_site.label_alt_id\n")
        cif_file.write("_atom_site.label_comp_id\n")
        cif_file.write("_atom_site.label_asym_id\n")
        cif_file.write("_atom_site.label_entity_id\n")
        cif_file.write("_atom_site.label_seq_id\n")
        cif_file.write("_atom_site.Cartn_x\n")
        cif_file.write("_atom_site.Cartn_y\n")
        cif_file.write("_atom_site.Cartn_z\n")
        cif_file.write("_atom_site.occupancy\n")
        cif_file.write("_atom_site.B_iso_or_equiv\n")
        cif_file.write("_atom_site.pdbx_PDB_model_num\n")
        cif_file.write("_atom_site.pdbx_PDB_ins_code\n")
        cif_file.write("_atom_site.auth_asym_id\n")
        
        # Atom-level data
        atom_counter = 1
        entity_id = 1
        for chain_id, chain_data in structure_dict.items():
            coords = chain_data["atom37"]
            seq = chain_data["seq"]
            b_factor = chain_data.get("b_factor", np.full(coords.shape[:2], np.nan))  # Default if missing
            
            for res_index in range(len(seq)):
                res_name = protein_letters_1to3.get(seq[res_index], "UNK")  # Default to UNK for unknown residues
                for atom_index in range(37):
                    x, y, z = coords[res_index, atom_index]
                    b_f = b_factor[res_index, atom_index]
                    
                    if not np.isnan([x, y, z]).any():  # Ensure coordinates are valid
                        atom_name = atom_types[atom_index]
                        atom_type_symbol = atom_name[0]
                        cif_file.write(
                            f"ATOM  {atom_counter:5d} {atom_type_symbol:<2} {atom_name:<4} . {res_name:<3} {chain_id} {entity_id} "
                            f"{res_index + 1:4d} {x:8.3f} {y:8.3f} {z:8.3f} 1.00 {b_f:>6.2f} 1 ? {chain_id}\n"
                        )
                        atom_counter += 1
            entity_id += 1
            
    print(f"Structure successfully written to {output_file} in CIF format.")

    

def dict_to_structure(structure_dict, structure_id="Reconstructed"):
    """
    Converts a dictionary from `extract_structure_to_dict` back into a Biopython Structure object.

    :param structure_dict: Dictionary containing chains and associated data.
                           Expected keys: 'seq', 'atom37', and optionally 'b_factor'.
    :param structure_id: Identifier for the reconstructed structure.
    :return: Biopython Structure object.
    """
    # Create a Biopython Structure object
    structure = Structure.Structure(structure_id)

    # Add a single model (assumes only one model is being reconstructed)
    model = Model.Model(0)
    structure.add(model)

    # Add header information if present
    if "header" in structure_dict:
        structure.header = structure_dict["header"]

    # Reconstruct chains
    for chain_id, chain_data in structure_dict.items():
        if chain_id == "header":  # Skip header if present
            continue

        # Create a chain
        chain = Chain.Chain(chain_id)
        model.add(chain)

        sequence = chain_data["seq"]
        atom37 = chain_data["atom37"]
        b_factor_present = "b_factor" in chain_data
        b_factor = chain_data.get("b_factor", None)

        # Reconstruct residues
        for res_index, res_code in enumerate(sequence):
            # Convert single-letter amino acid code to three-letter code
            if res_code not in protein_letters_1to3:
                resname = "UNK"  # Handle unknown residues
            else:
                resname = protein_letters_1to3[res_code]

            # Create a residue
            residue_id = (' ', res_index + 1, ' ')  # Residue ID with sequential numbering
            residue = Residue.Residue(residue_id, resname, " ")

            # Add atoms to the residue
            for atom_index, atom_name in enumerate(atom_types):
                coords = atom37[res_index, atom_index]
                if b_factor_present:
                    bfactor = b_factor[res_index, atom_index]
                else:
                    bfactor = 0.0  # Default B-factor if not provided

                if not np.isnan(coords).all():  # Only add atoms with valid coordinates
                    atom = Atom.Atom(
                        atom_name,  # Atom name
                        coords,     # 3D coordinates
                        bfactor,    # B-factor
                        1.0,        # Occupancy
                        " ",        # Alternate location indicator
                        atom_name,  # Full Atom name
                        atom_index,  # Serial number
                        atom_name[0],  # Element
                    )
                    residue.add(atom)

            # Add residue to the chain
            chain.add(residue)

    return structure

class PDBUtils:
    """
    A utility class for processing, cleaning, and handling PDB structures.
    """
    def __init__(self, verbose=True):
        self.verbose=verbose
        # Generate the list of allowed chain IDs
        self.allowed_chain_ids = [chr(i) for i in range(ord("A"), ord("Z") + 1)]  # A-Z
        self.allowed_chain_ids += [str(i) for i in range(10)]  # 0-9
        self.allowed_chain_ids += [chr(i) for i in range(ord("a"), ord("z") + 1)]  # a-z

        self.protein_letters_3to1 = protein_letters_3to1
        self.protein_letters_3to1.update({'UNK': 'X'})
        self.protein_letters_1to3 = {val: key for key, val in self.protein_letters_3to1.items()}
        
        self.atom_order = {atom_type: i for i, atom_type in enumerate(atom_types)}

    def get_file_format(self, pdb_file):
        """
        Determine whether the file is a cif, pdb, or some other type of file.

        :param pdb_file: path and name of the structure file
        :return: what type of file it is
        """
        
        extension = os.path.splitext(pdb_file)[1].lower()
        if ".pdb" in extension:
            return "pdb"
        elif ".cif" in extension:
            return "cif"
        else:
            # Fallback: Check content
            with open(pdb_file, "r") as file:
                first_line = file.readline().strip()
                if first_line.startswith(("HEADER", "ATOM", "HETATM", "TITLE", "REMARK")):
                    return "pdb"
                elif first_line.startswith("data_") or first_line.startswith("_"):
                    return "cif"
        raise ValueError("Unknown file format or unrecognized content. File and extension:", pdb_file, extension)
    
    def write_fasta_for_pdb(self, pdb_file, output_file=None):
        """
        Writes a FASTA file for the given pdb_file after cleaning it, including all chains.

        Each chain in the structure is written as a separate FASTA entry, where:
        - The header contains the chain ID (e.g., ">A").
        - The sequence is derived from the chain's residues.

        :param pdb_file: Input PDB or CIF file path.
        :param output_file: Path to the output FASTA file.
        """
        
        if output_file is None:
            base_name = os.path.splitext(pdb_file)[0]
        else:
            base_name = os.path.splitext(output_file)[0]
        
        structure, chain_dict_list = self.get_clean_structure(pdb_file)

        for i, model in enumerate(structure):
            if len(chain_dict_list) == 1:
                output_file = base_name + ".fasta"
            else:
                output_file = base_name + f"-frame{i}.fasta"

            with open(output_file, "w") as fasta_file:
                for chain in model:
                    chain_id = chain.id
                    sequence = []
    
                    # Build the sequence from residues in the chain
                    for residue in chain:
                        if residue.resname in protein_letters_3to1:
                            sequence.append(protein_letters_3to1[residue.resname])
                        else:
                            sequence.append("X")  # Placeholder for unknown residues
    
                    # Write the FASTA entry for the chain
                    fasta_file.write(f">{chain_id}\n")
                    fasta_file.write("".join(sequence) + "\n")
    
            if self.verbose: print(f"FASTA file written to {output_file}")
    
    def get_clean_structure(self, pdb_file, custom_seqres=None):
        """
        Main method to process a PDB file and provides the cleaned structure.

        This function orchestrates the cleaning and processing pipeline:
        1. Parses the input PDB file and extracts sequence information from atomic coordinates.
        2. Retains only the first model if multiple models exist in the structure.
        3. Attempts to read sequence records from the SEQRES section of the PDB or CIF file header.
        4. Aligns the observed sequences (from atomic coordinates) with header sequences (if available) 
           to identify and fill gaps.
        5. Updates residues marked as "UNK" (unknown) using the corrected sequences.

        :param pdb_file: Input PDB or CIF file path.
        :param custom_seqres: optional input for a seqres dictionary
        :return structure: biopython structure of cleaned structure
        :return chain_dict_list: list of dictionaries describing each biopython model
        """
        PDB_format = self.get_file_format(pdb_file)

        # Step 1: Attempt to read SEQRES records from the PDB or CIF file header
        if PDB_format=='pdb':
            seqres = self.read_seqres_pdb(pdb_file) if custom_seqres is None else custom_seqres 
            parser = PDB.PDBParser(QUIET=True)
        elif PDB_format == 'cif':
            seqres = self.read_seqres_cif(pdb_file) if custom_seqres is None else custom_seqres
            parser = PDB.MMCIFParser(QUIET=True, auth_residues=False)
        else:
            assert False, print("Unknown file format!")

        # Step 2: Parse and clean the input PDB file
        structure, chain_dict_from_atoms_list = self.clean_and_parse_pdb(pdb_file, seqres, parser)
        return structure, chain_dict_from_atoms_list
        
    
    def __call__(self, pdb_file, output_pdb_file=None, return_biopython_structure=False, write_file=True, custom_seqres=None):
        """
        Main method to process a PDB file and saves the cleaned structure.

        This function orchestrates the cleaning and processing pipeline:
        1. Extracts a clean strcture using the function get_clean_structure.
        2. Renames chains to ensure valid chain IDs (A-Z).
        3. Writes the cleaned structure and sequences to an output PDB file with updated SEQRES records.

        :param pdb_file: Input PDB or CIF file path.
        :param output_pdb_file: Output PDB file path.
        :param return_biopython_structure: bool of whether to return biopython structure
        :param write_file: bool of whether to create a structure file
        :param custom_seqres: inputted seqres, if provided
        :return: number of biopython models in the biopython structure
        :return: biopython structure
        """        
    
        # Step 1: Extract a clean strcture using the function get_clean_structure.
        updated_structure, updated_chain_dict_list = self.get_clean_structure(pdb_file, custom_seqres)

        # Step 2: Update chain IDs to ensure they are valid (A-Z)
        updated_structure = self.update_chain_ids(updated_structure)

        if output_pdb_file is None:
            base_name = os.path.splitext(pdb_file)[0] + '_clean'
        else:
            base_name = os.path.splitext(output_pdb_file)[0]

        if write_file:
            for i, model in enumerate(updated_structure):
                # Step 3: Write the cleaned structure and SEQRES records to the output PDB file
                if len(updated_chain_dict_list) == 1:
                    output_pdb_file = base_name + ".pdb"
                else:
                    output_pdb_file = base_name + f"-frame{i}.pdb"
                    
                self.write_pdb_with_seqres_from_structure(model, output_pdb_file)
        
        if return_biopython_structure:
            return len(updated_chain_dict_list), updated_structure
        else:
            return len(updated_chain_dict_list)

    def read_seqres_pdb(self, pdb_file):
        """
        Reads SEQRES records from a PDB file.

        SEQRES records provide the complete sequence of residues for each chain,
        including residues that may be missing from the atomic coordinates.

        This function extracts these records and returns a dictionary where:
        - Keys are chain IDs.
        - Values are sequences (as `Bio.Seq` objects).

        :param pdb_file: Path to the input PDB file.
        :return: Dictionary of chain IDs and sequences (e.g., {'A': Seq('MTGVL...')}).
        """
        chain_dict = {}

        # Open the PDB file and parse SEQRES records
        with open(pdb_file, "r") as handle:
            for record in PdbIO.PdbSeqresIterator(handle):
                if ":" in record.id:
                    chain_id = record.id.split(':')[-1]
                else:
                    chain_id = record.id
                chain_dict[chain_id] = str(record.seq)  # Extract sequence for each chain

        return chain_dict


    def read_seqres_cif(self, cif_file):
        """
        Reads SEQRES records from a CIF file.

        SEQRES records provide the complete sequence of residues for each chain,
        including residues that may be missing from the atomic coordinates.

        This function extracts these records from an mmCIF file and returns a dictionary where:
        - Keys are chain IDs.
        - Values are sequences (as `Bio.Seq` objects).

        :param cif_file: Path to the input CIF file.
        :return: Dictionary of chain IDs and sequences (e.g., {'A': Seq('MTGVL...')}).
        """

        # Trying to open and parse through the cif/mmcif file
        try:
            pdb_info = MMCIF2Dict(cif_file)
        except:
            print(f'Error: Could not load header from {cif_file}')
            pdb_info = {}

        # Grabbing the strand id and one letter sequence
        try:
            pdbx_seq_one_letter_code = pdb_info['_entity_poly.pdbx_seq_one_letter_code_can']
            pdbx_seq_one_letter_code = [seq.replace('\n', '') for seq in pdbx_seq_one_letter_code]
            pdbx_strand_id = pdb_info['_entity_poly.pdbx_strand_id']
            pdbx_strand_id = [id.split(',') for id in pdbx_strand_id]
        except:
            print('No sequence information in the PDB file')
            pdbx_seq_one_letter_code = []
            pdbx_strand_id = []

        # Creates a dictionary using the strand id and sequence
        try:
            assert len(pdbx_seq_one_letter_code) == len(pdbx_strand_id)
            master_seq_dict = {}
            for i in range(len(pdbx_seq_one_letter_code)):
                for key in pdbx_strand_id[i]:
                    master_seq_dict[key] = pdbx_seq_one_letter_code[i]
        except:
            print('Error: Length of sequence and strand id do not match')
            master_seq_dict = {}

        return master_seq_dict


    def clean_and_parse_pdb(self, pdb_file, seqres, parser):
        """
        Parses and cleans a PDB structure:
        - Removes non-standard residues, keeping only standard amino acids.
        - Detects gaps in residue numbering and fills them with placeholder residues (UNK).
        - Renumbers residues sequentially within each chain.
        - Extracts sequences from the cleaned structure.

        This function returns:
        1. The cleaned structure.
        2. A dictionary of chain IDs and sequences.

        :param pdb_file: Path to the input PDB file.
        :param seqres: inputted seqres
        :param parser: biopython tool to parse structure file
        :return structure: biopython structure of cleaned structure
        :return chain_dict_list: list of dictionaries describing each biopython model
        """

        # Parse the structure
        structure_all = parser.get_structure("PDB", pdb_file)

        structure = PDB.Structure.Structure(os.path.splitext(os.path.basename(pdb_file))[0])
        
        chain_dict_list = []
        models = list(structure_all)
        for model in models:
            chain_dict = {}  # Dictionary to store sequences for each chain

            for chain in list(model):
                chain_dict[chain.id] = []  # Initialize sequence list for the chain
                residues_to_keep = []  # Temporary list to store residues after cleaning
                prev_res = PDB.Residue.Residue((' ', None, ' '), "UNK", 0.0)

                # doing alignment if seqres exists
                aligned_seq = None
                if seqres and chain.id in seqres:
                    seq = "".join([protein_letters_3to1[res.resname] for res in chain if res.resname in protein_letters_3to1])
                    aligned_seq = ["UNK" if res not in self.protein_letters_3to1.values() else self.protein_letters_1to3[res] for res in self.find_missing_AA(seq, seqres[chain.id])]

                # Process each residue in the chain
                for i, residue in enumerate(chain):
                    # Check if the residue is a standard amino acid
                    if PDB.is_aa(residue, standard=True) and residue.id[0] == " ":
                        curr_res = residue  # Extract the residue number
    
                        # Detect gaps in residue numbering and fill with UNK placeholders
                        if prev_res.id[1] is None:
                            num_diff = 1
                        else:
                            num_diff = curr_res.id[1] - prev_res.id[1]

                        if prev_res.id[1] is not None and num_diff != 1:
                            flag = True
                            if aligned_seq:
                                if num_diff > 0:
                                    if (curr_res.id[1] - corr_index) >= len(aligned_seq):
                                        if (prev_res.id[1] - corr_index) >= (len(aligned_seq) - 1):
                                            raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. The error is most likely occuring due to errors in utilizing the SEQRES while parsing. It is recommend to rerun this file using the option 'custom_seqres={{}}' when calling on the PDBUtils class to parse these structures correctly.")

                                        elif aligned_seq[prev_res.id[1] - corr_index + 1] == curr_res.resname:
                                            corr_index += curr_res.id[1] - prev_res.id[1] - 1
                                            flag = False

                                        if flag:
                                            if "CA" not in prev_res or "CA" not in curr_res:
                                                raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. There is no alpha carbon present in either or both residues {(prev_res.id, prev_res.resname)} and {(curr_res.id, curr_res.resname)} located in chain {chain.id}.")
                                            if np.linalg.norm(prev_res["CA"].coord-curr_res["CA"].coord) <= 4.0:
                                                corr_index += curr_res.id[1] - prev_res.id[1] - 1
                                                flag = False
                                        if flag:
                                            raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. The error is occuring with residue indexing in Chain {chain.id} between residues {(prev_res.id, prev_res.resname)} and {(curr_res.id, curr_res.resname)}.")
                                    elif aligned_seq[prev_res.id[1] - corr_index] == prev_res.resname and aligned_seq[curr_res.id[1] - corr_index] == curr_res.resname:
                                        flag = False
                                        for res_ind in range(prev_res.id[1] + 1, curr_res.id[1]):
                                            ph_res = PDB.Residue.Residue((' ', i, ' '), aligned_seq[res_ind-corr_index], 0.0)
                                            residues_to_keep.append(ph_res)
                                    # elif aligned_seq[prev_res.id[1] - corr_index] == prev_res.resname and aligned_seq[prev_res.id[1] - corr_index + 1] == curr_res.resname:
                                    #     flag = False
                                    #     corr_index += curr_res.id[1] - prev_res.id[1] - 1
                                    if flag:
                                        if "CA" not in prev_res or "CA" not in curr_res:
                                            raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. There is no alpha carbon present in either or both residues {(prev_res.id, prev_res.resname)} and {(curr_res.id, curr_res.resname)} located in chain {chain.id}.")
                                        if np.linalg.norm(prev_res["CA"].coord-curr_res["CA"].coord) <= 4.0:
                                            corr_index += curr_res.id[1] - prev_res.id[1] - 1
                                            flag = False
                                    if flag:
                                        for res_ind in range(prev_res.id[1] + 1, curr_res.id[1]):
                                            # Create a placeholder residue for the gap
                                            ph_res = PDB.Residue.Residue((' ', res_ind, ' '), "UNK", 0.0)
                                            residues_to_keep.append(ph_res)
                                            corr_index += 1
                                else:
                                    if aligned_seq[prev_res.id[1] - corr_index + 1] == curr_res.resname:
                                        corr_index += curr_res.id[1] - prev_res.id[1] - 1
                                        flag = False
                                    if flag:
                                        if "CA" not in prev_res or "CA" not in curr_res:
                                            raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. There is no alpha carbon present in either or both residues {(prev_res.id, prev_res.resname)} and {(curr_res.id, curr_res.resname)} located in chain {chain.id}.")
                                        if np.linalg.norm(prev_res["CA"].coord-curr_res["CA"].coord) <= 4.0:
                                            corr_index += curr_res.id[1] - prev_res.id[1] - 1
                                            flag = False
                                    if flag:
                                        raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. The error is occuring with residue indexing in Chain {chain.id} between residues {(prev_res.id, prev_res.resname)} and {(curr_res.id, curr_res.resname)}.")
                            else:
                                if "CA" not in prev_res or "CA" not in curr_res:
                                    raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. There is no alpha carbon present in either or both residues {(prev_res.id, prev_res.resname)} and {(curr_res.id, curr_res.resname)} located in chain {chain.id}.")
                                if np.linalg.norm(prev_res["CA"].coord-curr_res["CA"].coord) <= 4.0:
                                    corr_index += curr_res.id[1] - prev_res.id[1] - 1
                                    flag = False
                                if flag:
                                    if num_diff <= 0:
                                        raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. The error is occuring with residue indexing in Chain {chain.id} between residues {(prev_res.id, prev_res.resname)} and {(curr_res.id, curr_res.resname)}.")
                                if flag:
                                    for res_ind in range(prev_res.id[1] + 1, curr_res.id[1]):
                                        # Create a placeholder residue for the gap
                                        ph_res = PDB.Residue.Residue((' ', res_ind, ' '), "UNK", 0.0)
                                        residues_to_keep.append(ph_res)

                        
                        if len(residues_to_keep) == 0:
                            corr_index = residue.id[1]
                        residues_to_keep.append(residue)  # Add the valid residue to the list
                        prev_res = residue

                # Remove all existing residues from the chain
                for residue in list(chain):
                    chain.detach_child(residue.id)
    
                # Add back the cleaned residues with renumbered IDs
                for i, residue in enumerate(residues_to_keep, start=1):
                    residue.id = (' ', i, ' ')  # Renumber residues sequentially
                    chain.add(residue)  # Add the cleaned residue back to the chain
    
                    # Convert the residue name to a single-letter code and build the sequence
                    if residue.resname in self.protein_letters_3to1:
                        res_name_one = self.protein_letters_3to1[residue.get_resname()]
                    else:
                        res_name_one = "X"  # Replace with placeholder
                    chain_dict[chain.id].append(res_name_one)

                # Convert the list of single-letter codes to a single sequence string
                chain_dict[chain.id] = "".join(chain_dict[chain.id])
    
                if len(chain_dict[chain.id]) == 0:
                    del chain_dict[chain.id]

            struct_chains = [chain.id for chain in model]
            for idx in struct_chains:
                if idx not in chain_dict.keys():
                    model.detach_child(idx) # need to filter the structure as well

            check_1 = [len([res for res in chain]) for chain in model]
            check_2 = [len(seq) for seq in chain_dict.values()]
            if check_1 != check_2:
                raise ValueError(f"An unexpected error occured when attempting to parse through file: {pdb_file}. Please manually curate structure file. The Biopython Structure and the recorded sequence dictionary do not match. There was an error that occured during the parsing of the structure file.")

            model.xtra["header"] = structure_all.header
            structure.add(model)
            chain_dict_list.append(chain_dict)
    
        return structure, chain_dict_list

    def update_chain_ids(self, structure):
        """
        Renames chains in a structure to sequential IDs, supporting up to 62 unique IDs.

        Chain IDs are assigned in the following order:
        1. Uppercase letters: A-Z (26 IDs).
        2. Digits: 0-9 (10 IDs).
        3. Lowercase letters: a-z (26 IDs).

        This ensures compliance with the PDB format while allowing the maximum 
        supported number of chains (62).

        :param structure: Biopython Structure object.
        :return: Structure with updated chain IDs.
        :raises ValueError: If the structure contains more than 62 chains.
        """

        for model in structure:
            
            chain_id_index = 0  # Index to track the next available chain ID
            existing_chains = [chain.id for chain in model]
    
            for i, chain in enumerate(model):
                if chain_id_index >= len(self.allowed_chain_ids):
                    raise ValueError("Exceeded the maximum number of chain IDs (62).")
    
                chain_id = chain.id
                comparison_chains = set(existing_chains) - set([chain_id])
                if chain_id not in self.allowed_chain_ids:
                    chain_id = self.allowed_chain_ids[chain_id_index]
                    chain_id_index += 1 
                while chain_id in comparison_chains:
                    chain_id = self.allowed_chain_ids[chain_id_index]
                    chain_id_index += 1
                chain.id = chain_id
                existing_chains[i] = chain_id
    
        return structure


    def find_relevant_seq(self, s, gap_char='X'):
        """
        Identifies the start and end indices of the relevant sequence 
        (non-gap region) in a string.

        This function is used to determine the range of a sequence where 
        actual residues (non-gap characters) exist, ignoring leading or 
        trailing gap characters.

        :param s: Sequence string with possible gaps (e.g., 'XXMATKX').
        :param gap_char: Character representing gaps (default: 'X').
        :return: Tuple (start_index, end_index), where:
                 - start_index: Index of the first non-gap character.
                 - end_index: Index of the last non-gap character.
        :raises ValueError: If the sequence contains only gaps.
        """
        # Find the first non-gap character
        start_index = s.find(next(char for char in s if char != gap_char))

        # Find the last non-gap character
        end_index = len(s) - s[::-1].find(next(char for char in s[::-1] if char != gap_char)) - 1

        return start_index, end_index


    def find_missing_AA(self, seq, master_seq):
        """
        Fills in missing amino acids in the observed sequences by aligning them
        with the master sequences.
 
        Steps:
        1. For each chain, align the observed sequence (`chain_dict`) with the 
           master sequence (`master_chain_dict`) using global alignment.
        2. Identify gaps in the observed sequence and fill them with residues 
           from the aligned master sequence.
        3. Return the updated chain dictionary with gaps filled.
 
        :param chain_dict: Dictionary of observed chain sequences (from atoms in the PDB).
                           Example: {'A': 'MGTTXLY'}
        :param master_chain_dict: Dictionary of master chain sequences (from SEQRES in the header).
                                  Example: {'A': 'MGTTELY'}
        :return: Updated chain dictionary with missing residues filled.
        """
        original_seq = seq
        seq = seq.replace("X", "")

        if seq == master_seq:
            # If sequences match, no update is needed
            return seq
        else:
            try:
                # Perform global sequence alignment
                alignments = pairwise2.align.globalms(master_seq, seq, 5, -3, -1.0, -0.5, gap_char="X")
                aligned_seq_master = alignments[0].seqA  # Aligned master sequence
                aligned_seq = alignments[0].seqB         # Aligned observed sequence

                if aligned_seq == 'X' * len(aligned_seq):
                    raise ValueError(f"Alignment issue for Chain {chain_id}. Skipping.")

                # Determine the region of alignment that contains meaningful residues
                start, end = self.find_relevant_seq(aligned_seq)
                aligned_seq = aligned_seq[start:end + 1]
                aligned_seq_master = aligned_seq_master[start:end + 1]

                # Fill missing residues in the observed sequence using the master sequence
                # idx_not_X = [i for i, ltr in enumerate(aligned_seq) if ltr != "X"]
                # aligned_seq = "".join(
                #     [aligned_seq[i] if i in idx_not_X else aligned_seq_master[i] for i in range(len(aligned_seq))]
                # )
                aligned_seq = "".join([aligned_seq[i] if aligned_seq[i] != "X" else aligned_seq_master[i] for i in range(len(aligned_seq))])
                return aligned_seq
            except:
                return seq


    def replace_unk_with_sequence(self, model, sequence_dict):
        """
        Replaces residues labeled as "UNK" (unknown) in the structure with their
        corresponding amino acids from the provided sequence dictionary.

        Steps:
        1. Iterate through each chain in the structure.
        2. Check if the chain exists in the sequence dictionary.
        3. Verify that the sequence length matches the number of residues in the chain.
        4. Replace "UNK" residues with their correct amino acid names from the sequence.
        5. Ensure consistency between known residues in the sequence and structure.

        :param structure: Biopython Structure object.
        :param sequence_dict: Dictionary of chain sequences (e.g., {'A': 'MGTTELY'}).
        :return: Updated Biopython Structure object with corrected residues.
        """

        if type(model) == Bio.PDB.Structure.Structure:
            model = model[0]

        for chain in model:
            # Skip chains not present in the sequence dictionary
            if chain.id not in sequence_dict:
                print(f"Warning: No sequence provided for chain {chain.id}. Skipping.")
                continue

            # Retrieve the sequence for the current chain
            sequence = sequence_dict[chain.id]
            residues = list(chain)  # Get all residues in the chain

            # Check for sequence length mismatch
            if len(residues) != len(sequence):
                print(f"Warning: Length mismatch for chain {chain.id}. Skipping.")
                continue
            
            # Check for empty chains
            if not residues:
                # Log a warning and remove the empty chain
                print(f"Warning: Chain {chain.id} is empty and will be removed.")
                model.detach_child(chain.id)  # Remove the empty chain from the structure
                continue
            
            # Replace "UNK" residues with the correct amino acid names
            for i, residue in enumerate(residues):
                if residue.resname == "UNK":
                    # Update "UNK" with the correct amino acid name from the sequence
                    residue.resname = self.protein_letters_1to3[sequence[i]]
                else:
                    # Verify that existing residue names match the provided sequence
                    print(residue.resname, self.protein_letters_1to3[sequence[i]])
                    assert residue.resname == self.protein_letters_1to3[sequence[i]], (
                        f"Error in chain {chain.id}: Residue mismatch between structure and sequence. "
                        "Please correct the sequence or structure before proceeding.")

        return model
    
    def keep_first_model_only(self, structure):
        """
        Retains only the first model in the structure if multiple models are present.

        PDB files can contain multiple models, each representing a different 
        conformation of the structure. This function keeps only the first model 
        and removes all subsequent models.

        Steps:
        1. Check how many models are present in the structure.
        2. If more than one model exists, detach all models except the first.

        :param structure: Biopython Structure object.
        :return: Structure with a single model retained.
        """
        # Get a list of all models in the structure
        models = list(structure)

        if len(models) > 1:
            # If there are multiple models, log the number of models
            print(f"Structure has {len(models)} models. Keeping only the first model.")

            # Detach all models except the first one
            for model in models[1:]:
                structure.detach_child(model.id)

        return structure


    

    def write_pdb_with_seqres_from_structure(self, model, output_file,remark="Modified by Bryan Munoz Rivero, Sanofi"):
        """
        Writes a PDB file with SEQRES records generated directly from the structure.

        This function performs the following:
        1. Validates chain IDs to ensure compliance with PDB standards.
        2. Extracts the complete sequence for each chain in the structure, filling 
           gaps in residue numbering with "UNK".
        3. Writes the SEQRES records and the modified structure to an output PDB file.
        4. Adds a custom remark to the file header.

        :param structure: Biopython Structure object (already modified, if needed).
        :param output_file: Path to the output PDB file.
        :param remark: Custom remark to add at the beginning of the file header.
        """
        io = PDB.PDBIO()
        sequence_dict = {}

        # Step 1: Validate chain IDs
        if type(model) == Bio.PDB.Structure.Structure:
            model = model[0]
        assert self.validate_pdb_structure_chains(model), "Invalid chain IDs in the structure!"

        # Step 2: Extract sequences for each chain
        for chain in model:
            chain_sequence = []  # List to store residue names for the chain
            residues = list(chain)

            if not residues:
                # Skip empty chains
                continue

            # Get residue numbers to detect gaps
            for residue in residues:
                try:
                    residue.id[1]
                except:
                    raise ValueError(residue.resname, residue.id)
            residue_numbers = [residue.id[1] for residue in residues]

            # Iterate through residue numbers and fill gaps with UNK
            for i in range(min(residue_numbers), max(residue_numbers) + 1):
                if i in residue_numbers:
                    residue = chain[(" ", i, " ")]
                    chain_sequence.append(residue.resname)
                else:
                    chain_sequence.append("UNK")  # Placeholder for missing residues

            # Store the sequence for the chain
            sequence_dict[chain.id] = chain_sequence

        # Step 3: Write the structure and SEQRES records
        ext = os.path.splitext(output_file)[1]
        if ext != ".pdb":
            output_file = os.path.splitext(output_file)[0] + ".pdb"
            if ext != "":
                print("You specified an extension that is not '.pdb'. This function only creates PDB files, so please keep this in mind.")
        with open(output_file, "w") as f:
            # Write the header information
            try:
                for key, value in model.xtra["header"].items():
                    if isinstance(value, str):
                        f.write(f"{key.upper():<10} {value}\n")
                    elif isinstance(value, list):
                        for item in value:
                            f.write(f"{key.upper():<10} {item}\n")
            except:
                pass
            
            # Add the custom remark at the top
            f.write(f"REMARK 99 {remark}\n")
            
            # Write SEQRES records
            # f.write("SEQRES RECORDS\n")
            for chain_id, sequence in sequence_dict.items():
                # SEQRES allows up to 13 residues per line
                for idx, i in enumerate(range(0, len(sequence), 13)):
                    residues = sequence[i:i+13]  # Extract up to 13 residues
                    formatted_residues = " ".join(residues)  # Join residues with spaces
                    
                    f.write(f"SEQRES {idx+1:>3}{chain_id:>2} {len(sequence):>4}  {formatted_residues}\n")
            f.write("\n")

            # Write the structure itself
            io.set_structure(model)
            io.save(f)

        if self.verbose: print(f"Modified structure with SEQRES records saved to {output_file}")
        
    def validate_pdb_structure_chains(self, model):
        """
        Validates the chain IDs and the total number of chains in a PDB structure 
        to ensure compliance with PDB format constraints.

        Validation checks:
        1. Each chain ID must be a single alphanumeric character (A-Z, 0-9) or a 
           valid special character (e.g., space or underscore).
        2. The total number of chains in the structure must not exceed 62 (A-Z, 0-9, a-z).

        :param structure: Biopython Structure object.
        :return: True if all chain IDs are valid and the number of chains is within limits, False otherwise.
        """

        def check_alphanum(chain_id):
            """
            Checks if a chain ID is valid.
            A valid chain ID:
            - Is a single character.
            - Is alphanumeric (A-Z, 0-9) or a special character (' ', '_').
            """
            return isinstance(chain_id, str) and len(chain_id) == 1 and (chain_id.isalnum() or chain_id in " _")

        # Get all chain IDs from the structure
        if type(model) == Bio.PDB.Structure.Structure:
            model = model[0]
        chain_ids = [check_alphanum(chain.id) for chain in model]

        # Check if the number of chains is within the PDB limit (62)
        if len(chain_ids) <= 62 and all(chain_ids):
            return True
        else:
            return False
        
    def extract_structure_to_dict(
        self,
        structure,
        add_header: bool = False,
        model_to_extract: int = 0,
        custom_header: dict = None
    ) -> dict:
        """
        Extract a Biopython Structure or Model into a nested dictionary with per-chain sequence
        and coordinate/B-factor arrays.

        Parameters
        ----------
        structure : Bio.PDB.Structure.Structure or Bio.PDB.Model.Model
            The input Structure object (assumed cleaned) or a single Model. If a Structure
            containing multiple models is passed, the model at index `model_to_extract` will
            be used.
        add_header : bool, default=False
            If True, include the structureâ€™s header (or `custom_header`) under the key 'header'.
        model_to_extract : int, default=0
            Index of the model to extract when `structure` is a multi-model Structure.
        custom_header : dict or None, default=None
            Optional header to use instead of `structure.header` when `add_header` is True.

        Returns
        -------
        dict
            A mapping from chain ID (str) to a dict with keys:
              - 'seq'      : str
                    One-letter amino acid sequence (unknown residues as 'X').
              - 'atom37'   : np.ndarray, shape (N, 37, 3)
                    Cartesian coordinates for up to 37 heavy atoms per residue; NaN where
                    atoms are missing.
              - 'b_factor' : np.ndarray, shape (N, 37)
                    Corresponding B-factors; NaN where not available.
            If `add_header` is True, also includes the key:
              - 'header'   : dict
                    The structure header or `custom_header`.
        """
        # Map residue and atom types to indices
        atom37_size = len(self.atom_order)  # Total number of standard heavy atoms

        # Initialize the result dictionary
        structure_dict = {}
        
        # Handle multi-model Structure
        if type(structure) is Bio.PDB.Structure.Structure:
            print(f'Contains multiple models, {len([model for model in structure.get_models()])} total and extracting model number {model_to_extract}!')
            structure = structure[model_to_extract]

        for chain in structure:
            chain_id = chain.id
            residues = list(chain)
            num_residues = len(residues)

            # Initialize sequence and atom arrays
            sequence = []
            atom37 = np.full((num_residues, atom37_size, 3), np.nan)  # (x, y, z) per atom
            b_factor = np.full((num_residues, atom37_size), np.nan)   # B-factor per atom

            for i, residue in enumerate(residues):
                # Add residue to sequence
                if residue.resname in protein_letters_3to1:
                    sequence.append(protein_letters_3to1[residue.resname])
                else:
                    sequence.append("X")  # Placeholder for unknown residues

                # Populate atom coordinates and B-factors
                for atom in residue:
                    atom_name = atom.get_name()
                    if atom_name in self.atom_order:
                        atom_index = self.atom_order[atom_name]
                        atom37[i, atom_index, :] = atom.get_coord()  # 3D coordinates
                        b_factor[i, atom_index] = atom.get_bfactor()  # B-factor

            # Store chain information in the dictionary
            structure_dict[chain_id] = {
                "seq": "".join(sequence),
                "atom37": atom37,
                "b_factor": b_factor
            }

        if add_header:
            if custom_header is None:
                try:
                    header = structure.xtra.get('header', {})
                except Exception as e:
                    print('Not able to extract the header!', e)
            else:
                header = custom_header
            structure_dict.update({'header': header})
        return structure_dict
    
    def save_npy_file(self, structure_dict, output_file):
        
        np.save(f'{output_file}', structure_dict)
        
        if self.verbose: print(f'Successfully saved {output_file}')

        
def main():
    parser = argparse.ArgumentParser(description="Utility for cleaning and handling PDB structures.")
    
    # Add arguments
    parser.add_argument(
        "input_file",
        nargs="?",
        help="Path to the input PDB or CIF file. If omitted, the --test option must be used.",
    )
    parser.add_argument(
        "--output_file",
        help="Path to save the processed PDB file. Defaults to '<input_file>_clean.pdb'.",
    )
    parser.add_argument(
        "--fasta",
        help="Path to save the FASTA file. Defaults to '<input_file>.fasta'.",
    )
    parser.add_argument(
        "--npy",
        help="Path to save NumPy arrays of structure data. Defaults to '<input_file>.npy'.",
    )
    parser.add_argument(
        "--test",
        action="store_true",
        help="Run a test using predefined test.pdb and test.cif files.",
    )
    
    args = parser.parse_args()
    
    # Handle the test case
    if args.test:
        test_files = ["test_pdb.pdb", "test_cif.cif"]
        unit_test(test_files)
        return

    # Initialize the utility class
    pdb_utils = PDBUtils()
    
    # If no input file is provided and --test is not used, show an error
    if not args.input_file:
        parser.error("An input file must be specified unless --test is used.")

    # Process the input file
    input_file = args.input_file
    output_file = args.output_file or f"{os.path.splitext(input_file)[0]}_clean.pdb"
    fasta_file = args.fasta or f"{os.path.splitext(input_file)[0]}.fasta"
    npy_file = args.npy or f"{os.path.splitext(input_file)[0]}.npy"

    # Parse, clean, and save the structure
    structure, updated_chain_dict = pdb_utils.get_clean_structure(input_file)
    pdb_utils.write_pdb_with_seqres_from_structure(structure, output_file)
    pdb_utils.write_fasta_for_pdb(input_file, fasta_file)
    structure_dict = pdb_utils.extract_structure_to_dict(structure)
    pdb_utils.save_npy_file(structure_dict, npy_file)

    print(f"Processing completed for {input_file}.")
    print(f"Cleaned PDB saved to {output_file}.")
    print(f"FASTA file saved to {fasta_file}.")
    print(f"NumPy structure data saved to {npy_file}.")

    
def unit_test(test_files):
    
    # Initialize the utility class
    pdb_utils = PDBUtils()
    
    for test_file in test_files:
        print(f"Testing with file: {test_file}")
        
        # Output file names
        output_pdb = f"{os.path.splitext(test_file)[0]}_clean.pdb"
        output_fasta = f"{os.path.splitext(test_file)[0]}_clean.fasta"
        output_npy = f"{os.path.splitext(test_file)[0]}_clean.npy"
        output_cif = f"{os.path.splitext(test_file)[0]}_clean.cif"

        # Step 1: Process the structure
        structure = pdb_utils(test_file, output_pdb, return_biopython_structure=True)
        pdb_utils.write_fasta_for_pdb(test_file, output_fasta)

        # Step 2: Convert structure to dictionary
        structure_dict = pdb_utils.extract_structure_to_dict(structure)

        # Save structure dictionary as .npy
        pdb_utils.save_npy_file(structure_dict, output_npy)

        # Step 3: Write CIF file from the dictionary
        write_dict_to_cif(structure_dict, output_cif, remark="Generated during test")

        # Step 4: Convert dictionary back to Biopython Structure and validate
        reconstructed_structure = dict_to_structure(structure_dict)

        # Optional: Save the reconstructed structure as PDB for validation
        reconstructed_pdb = f"{os.path.splitext(test_file)[0]}_reconstructed.pdb"
        pdb_utils.write_pdb_with_seqres_from_structure(reconstructed_structure, reconstructed_pdb)

    print("Test completed successfully.")
    return

if __name__ == "__main__":
    main()
